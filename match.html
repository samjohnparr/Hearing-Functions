<!doctype html>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Hearing Functions — Match the Figure to the Sound</title>
<style>
  :root{--w:160px; --h:120px}
  body{font-family:system-ui,Segoe UI,Helvetica,Arial,sans-serif;max-width:1000px;margin:24px auto;padding:0 12px;line-height:1.4}
  h1{font-size:1.4rem;margin:.25rem 0 1rem}
  h2{font-size:1.1rem;margin:1.25rem 0 .5rem}
  .section{border:1px solid #ddd;border-radius:12px;padding:12px;margin:14px 0;background:#fafafa}
  .grid{display:grid;grid-template-columns:1fr 1fr;gap:16px}
  .audios .item{border:1px solid #ddd;border-radius:10px;padding:10px;background:white;margin-bottom:10px}
  .label{font-weight:600}
  .figs{display:grid;grid-template-columns:repeat(3, minmax(var(--w), 1fr));gap:12px}
  .fig{position:relative;border:1px solid #ddd;border-radius:10px;background:white;padding:8px}
  .badge{position:absolute;left:8px;top:8px;background:#333;color:#fff;border-radius:8px;padding:2px 8px;font-size:.8rem}
  svg{width:100%;height:auto;max-width:var(--w);max-height:var(--h);display:block;margin:0 auto}
  select{padding:.35rem;border-radius:8px;border:1px solid #bbb}
  .controls{display:flex;gap:8px;align-items:center;margin-top:8px;flex-wrap:wrap}
  button{padding:.55rem .9rem;border-radius:10px;border:1px solid #bbb;background:#f5f5f5;cursor:pointer}
  .score{font-weight:700}
  .ok{color:#0a7a26}
  .bad{color:#c00}
  .muted{color:#666;font-size:.92rem}
  .pill{display:inline-block;padding:.1rem .5rem;border-radius:999px;border:1px solid #ccc;background:#fff;font-size:.8rem}
  .key{margin-top:6px}
  .key span{margin-right:6px}
</style>

<h1>Hearing Functions — Match the Figure to the Sound</h1>
<p class="muted">All clips use the same timbre/range/tempo (sine, 40 steps, 0.20 s per step, 0.02 s gaps, 220–880 Hz). Choose a figure for each sound, then “Check answers”.</p>

<div id="app"></div>

<script>
/* ============ CONFIG ============ */
/* Audio files must live in /audio with these exact names (from the 12-clip Colab set). */
const CONFIG = {
  V2P: { // value -> pitch: match sound to graph of f(x)
    prompts: [
      { id:"V2P_linear_pos_slow",  src:"audio/V2P_linear_pos_slow.wav",  correct:"g_lin_pos_slow",  label:"linear ↑ (gentle)" },
      { id:"V2P_linear_pos_fast",  src:"audio/V2P_linear_pos_fast.wav",  correct:"g_lin_pos_fast",  label:"linear ↑ (steep)" },
      { id:"V2P_linear_neg_slow",  src:"audio/V2P_linear_neg_slow.wav",  correct:"g_lin_neg_slow",  label:"linear ↓ (gentle)" },
      { id:"V2P_linear_neg_fast",  src:"audio/V2P_linear_neg_fast.wav",  correct:"g_lin_neg_fast",  label:"linear ↓ (steep)" },
      { id:"V2P_exponential_fast", src:"audio/V2P_exponential_fast.wav", correct:"g_exp_fast",       label:"exponential ↑" },
      { id:"V2P_constant",         src:"audio/V2P_constant.wav",         correct:"g_const",          label:"constant" },
    ],
    figures: [
      { id:"g_lin_pos_slow",  fn:(x)=>0.30*x,      domain:[-5,5],  caption:"y=0.3x" },
      { id:"g_lin_pos_fast",  fn:(x)=>0.80*x,      domain:[-5,5],  caption:"y=0.8x" },
      { id:"g_lin_neg_slow",  fn:(x)=>-0.30*x,     domain:[-5,5],  caption:"y=-0.3x" },
      { id:"g_lin_neg_fast",  fn:(x)=>-0.80*x,     domain:[-5,5],  caption:"y=-0.8x" },
      { id:"g_exp_fast",      fn:(x)=>Math.pow(2, x/1.5), domain:[-4,4], caption:"y=2^{x/1.5}" },
      { id:"g_const",         fn:(x)=>2.0,         domain:[-5,5],  caption:"y=2" },
    ],
    note: "V2P: rising pitch ⇒ function increasing; falling ⇒ decreasing."
  },
  S2P: { // slope -> pitch: match sound to the ORIGINAL function whose slope behaves like the audio
    prompts: [
      { id:"S2P_linear_constant_slope", src:"audio/S2P_linear_constant_slope.wav", correct:"g_linear",     label:"linear (constant slope)" },
      { id:"S2P_quadratic_concave_up",  src:"audio/S2P_quadratic_concave_up.wav",  correct:"g_quad",       label:"quadratic (concave up)" },
      { id:"S2P_sqrt_concave_down",     src:"audio/S2P_sqrt_concave_down.wav",     correct:"g_sqrt",       label:"sqrt (concave down)" },
      { id:"S2P_log_concave_down",      src:"audio/S2P_log_concave_down.wav",      correct:"g_log",        label:"log (concave down)" },
      { id:"S2P_cubic_concave_up",      src:"audio/S2P_cubic_concave_up.wav",      correct:"g_cubic_pos",  label:"cubic on [0,2] (concave up)" },
      { id:"S2P_cubic_concave_down",    src:"audio/S2P_cubic_concave_down.wav",    correct:"g_cubic_neg",  label:"cubic on [-2,0] (concave down)" },
    ],
    figures: [
      { id:"g_linear",    fn:(x)=>0.6*x,                          domain:[-5,5],  caption:"linear (slope constant)" },
      { id:"g_quad",      fn:(x)=>x*x,                             domain:[0,4],  caption:"quadratic (concave up)"  },
      { id:"g_sqrt",      fn:(x)=>Math.sqrt(Math.max(1e-9,x)),    domain:[0.1,4],caption:"sqrt (concave down)"     },
      { id:"g_log",       fn:(x)=>Math.log(Math.max(1e-6,x)),     domain:[0.1,4],caption:"log (concave down)"      },
      { id:"g_cubic_pos", fn:(x)=>x**3,                            domain:[0,2],  caption:"cubic on [0,2]"          },
      { id:"g_cubic_neg", fn:(x)=>x**3,                            domain:[-2,0], caption:"cubic on [-2,0]"         },
    ],
    note: "S2P: rising pitch ⇒ slope increasing (concave up); falling ⇒ slope decreasing (concave down)."
  }
};

/* ============ UTILS ============ */
function shuffle(a){
  for(let i=a.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[a[i],a[j]]=[a[j],a[i]];}
  return a;
}
function sampleY(fn, domain, N=200){
  const [x0,x1]=domain, xs=[...Array(N)].map((_,i)=>x0+(x1-x0)*i/(N-1));
  const ys=xs.map(fn);
  let ymin=Math.min(...ys), ymax=Math.max(...ys);
  if(!isFinite(ymin)||!isFinite(ymax)){ymin=-1;ymax=1;}
  if (ymax-ymin<1e-6){ymax=ymin+1;}
  // add 10% padding
  const pad=0.1*(ymax-ymin);
  return {xs, ys, ymin:ymin-pad, ymax:ymax+pad};
}
function axisMap(x, x0,x1, W){ return (x-x0)/(x1-x0)*W; }
function axisMapY(y, y0,y1, H){ return H-(y-y0)/(y1-y0)*H; }

function drawGraphSVG(el, fn, domain, caption){
  const W=160,H=120, pad=16;
  const svgNS="http://www.w3.org/2000/svg";
  const svg=document.createElementNS(svgNS,"svg");
  svg.setAttribute("viewBox",`0 0 ${W} ${H}`);

  const {xs,ys,ymin,ymax}=sampleY(fn, domain, 200);
  // axes
  const ax=document.createElementNS(svgNS,"path");
  const x0=Math.max(domain[0],0), y0=Math.max(ymin,0);
  // simple axes lines at x=0 and y=0 if visible
  const gElems=[];
  if (domain[0] <= 0 && domain[1] >= 0){
    const x=axLineX(0, domain, ymin, ymax, W, H); gElems.push(x);
  }
  if (ymin <= 0 && ymax >= 0){
    const y=axLineY(0, domain, ymin, ymax, W, H); gElems.push(y);
  }
  function axLineX(xv,x0x1,y0y1,W,H){
    const x=axisMap(xv, x0x1[0], x0x1[1], W);
    const l=document.createElementNS(svgNS,"line");
    l.setAttribute("x1",x); l.setAttribute("x2",x);
    l.setAttribute("y1",0); l.setAttribute("y2",H);
    l.setAttribute("stroke","#bbb"); l.setAttribute("stroke-width","1");
    return l;
  }
  function axLineY(yv,x0x1,y0y1,W,H){
    const y=axisMapY(yv, y0y1[0], y0y1[1], H);
    const l=document.createElementNS(svgNS,"line");
    l.setAttribute("x1",0); l.setAttribute("x2",W);
    l.setAttribute("y1",y); l.setAttribute("y2",y);
    l.setAttribute("stroke","#bbb"); l.setAttribute("stroke-width","1");
    return l;
  }
  gElems.forEach(e=>svg.appendChild(e));

  // graph path
  let d="";
  for(let i=0;i<xs.length;i++){
    const X=axisMap(xs[i], domain[0], domain[1], W);
    const Y=axisMapY(ys[i], ymin, ymax, H);
    d += (i===0?`M ${X} ${Y}`:` L ${X} ${Y}`);
  }
  const path=document.createElementNS(svgNS,"path");
  path.setAttribute("d", d);
  path.setAttribute("fill","none");
  path.setAttribute("stroke","#222");
  path.setAttribute("stroke-width","2");
  svg.appendChild(path);

  // caption
  const cap=document.createElement("div");
  cap.className="muted";
  cap.style.textAlign="center";
  cap.style.marginTop="4px";
  cap.textContent=caption||"";

  el.innerHTML="";
  el.appendChild(svg);
  el.appendChild(cap);
}

/* ============ RENDER ============ */
function renderSection(root, key){
  const cfg=CONFIG[key];
  // shallow copies to shuffle without touching CONFIG
  const items = cfg.prompts.map(x=>({...x}));
  const figs  = cfg.figures.map(x=>({...x}));

  shuffle(items); shuffle(figs);

  // assign letters to figures A..F
  const letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".split("");
  figs.forEach((f,i)=> f.letter = letters[i]);

  // map id->letter for grading
  const letterByFigId = Object.fromEntries(figs.map(f=>[f.id,f.letter]));

  const sec=document.createElement("div");
  sec.className="section";

  const hdr=document.createElement("h2");
  hdr.textContent = (key==="V2P" ? "Part A — V2P: Value→Pitch" : "Part B — S2P: Slope→Pitch");
  sec.appendChild(hdr);

  const note=document.createElement("div");
  note.className="muted";
  note.textContent = cfg.note;
  sec.appendChild(note);

  const grid=document.createElement("div");
  grid.className="grid";
  sec.appendChild(grid);

  // Left: audio items with dropdowns
  const left=document.createElement("div");
  left.className="audios";
  grid.appendChild(left);

  const selects=[];
  items.forEach((it, idx)=>{
    const card=document.createElement("div");
    card.className="item";
    const title=document.createElement("div");
    title.innerHTML = `<span class="label">Sound ${idx+1}:</span> <span class="muted">${it.label}</span>`;
    const player=document.createElement("audio");
    player.controls=true; player.src=it.src; player.style.width="100%";
    const sel=document.createElement("select");
    sel.innerHTML = `<option value="">Choose figure…</option>` + figs.map(f=>`<option value="${f.letter}">${f.letter}</option>`).join("");
    selects.push({sel, item:it});
    card.appendChild(title); card.appendChild(player); card.appendChild(document.createElement("br")); card.appendChild(sel);
    left.appendChild(card);
  });

  // Right: figures grid
  const right=document.createElement("div");
  right.className="figs";
  figs.forEach(f=>{
    const fig=document.createElement("div"); fig.className="fig";
    const badge=document.createElement("div"); badge.className="badge"; badge.textContent=f.letter;
    const plot=document.createElement("div");
    fig.appendChild(badge); fig.appendChild(plot);
    right.appendChild(fig);
    drawGraphSVG(plot, f.fn, f.domain, f.caption);
  });
  grid.appendChild(right);

  // Controls
  const controls=document.createElement("div");
  controls.className="controls";
  const btnCheck=document.createElement("button"); btnCheck.textContent="Check answers"; btnCheck.disabled=true;
  const btnReset=document.createElement("button"); btnReset.textContent="Reset choices";
  const out=document.createElement("span"); out.className="score";

  const btnCSV=document.createElement("button"); btnCSV.textContent="Download CSV"; btnCSV.style.display="none";

  controls.appendChild(btnCheck); controls.appendChild(btnReset); controls.appendChild(out); controls.appendChild(btnCSV);
  sec.appendChild(controls);

  // Enable check once all selected
  function updateEnable(){
    btnCheck.disabled = selects.some(s=>!s.sel.value);
  }
  selects.forEach(s=> s.sel.addEventListener("change", updateEnable));
  updateEnable();

  // Grade
  btnCheck.addEventListener("click", ()=>{
    let correct=0;
    const rows=[["section","item_label","audio_id","chosen_letter","correct_letter","is_correct"]];
    selects.forEach((s, i)=>{
      const chosen=s.sel.value;
      const correctLetter = letterByFigId[ cfg.prompts.find(p=>p.id===s.item.id).correct ];
      const good = chosen===correctLetter;
      if(good) correct++;
      // visual tick/cross
      const mark = document.createElement("span");
      mark.className = good ? "ok pill" : "bad pill";
      mark.style.marginLeft="8px";
      mark.textContent = good ? "✔" : "✖";
      s.sel.after(mark);
      rows.push([key, s.item.label, s.item.id, chosen, correctLetter, good]);
    });
    out.textContent = ` Score: ${correct} / ${selects.length}`;
    btnCSV.style.display="inline-block";
    // build CSV
    const csv = rows.map(r=>r.map(v=>String(v).replaceAll('"','""')).map(v=>`"${v}"`).join(",")).join("\n");
    btnCSV.onclick = ()=>{
      const blob=new Blob([csv],{type:"text/csv"});
      const a=document.createElement("a");
      a.href=URL.createObjectURL(blob);
      a.download=`results_${key}_${Date.now()}.csv`;
      a.click();
    };
    // lock UI
    btnCheck.disabled=true;
    selects.forEach(s=> s.sel.disabled=true);
  });

  btnReset.addEventListener("click", ()=>{
    selects.forEach(s=>{
      s.sel.value="";
      s.sel.disabled=false;
      // remove any ✔/✖ next to select
      let n=s.sel.nextSibling;
      while(n && n.classList && (n.classList.contains("ok")||n.classList.contains("bad"))){
        let rem=n; n=n.nextSibling; rem.remove();
      }
    });
    out.textContent="";
    btnCSV.style.display="none";
    updateEnable();
  });

  root.appendChild(sec);
}

const app=document.getElementById("app");
renderSection(app, "V2P");
renderSection(app, "S2P");
</script>
